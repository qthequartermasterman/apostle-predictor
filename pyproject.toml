[project]
name = "apostle-predictor"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
authors = [
    { email = "andrew@protopia.ai" }
]
requires-python = ">=3.12"
dependencies = [
    "auto-pydantic-cache==1.1.1",
    "beautifulsoup4==4.13.5",
    "httpx==0.28.1",
    "pandas==2.3.2",
    "pydantic==2.11.7",
]

[build-system]
requires = ["uv_build>=0.8.14,<0.9.0"]
build-backend = "uv_build"

[dependency-groups]
dev = [
    "pre-commit==4.0.1",
    "pyrefly==0.32.0",
    "pytest==8.4.2",
    "ruff==0.12.12",
    "ty==0.0.1a20",
]

[tool.ruff]
# Set line length to 100 for better readability with descriptive names
line-length = 100

# Target Python 3.12
target-version = "py312"

[tool.ruff.lint]
# Enable ALL available rules
select = ["ALL"]
# Exclude some overly strict or inappropriate rules
ignore = [
    # Allow certain naming patterns
    "N999",  # Invalid module name (conflicts with package structure)

    # Allow certain docstring patterns
    "D100",  # Missing docstring in public module (not always needed)
    "D104",  # Missing docstring in public package (not always needed)

    # Allow certain import patterns
    "TCH",   # flake8-type-checking (can be overly aggressive)

    # Allow print statements for CLI output
    "T201",  # print found

    # Allow certain complexity
    "PLR0913",  # Too many arguments to function call (sometimes needed)
    "PLR0912",  # Too many branches (sometimes needed for complex logic)
    "PLR0915",  # Too many statements (sometimes needed for complex functions)
    "C901",     # Too complex (sometimes needed for algorithms)

    # Allow certain patterns for CLI and main functions
    "FBT001",   # Boolean positional argument (common in CLI)
    "FBT002",   # Boolean default positional argument (common in CLI)

    # Allow certain patterns for private methods and unused variables
    "SLF001",   # Private member accessed (sometimes needed for testing)
    "ARG002",   # Unused method argument (sometimes needed for interface consistency)
    "B007",     # Loop control variable not used (sometimes needed for unpacking)

    # Allow certain date/time patterns
    "DTZ011",   # datetime.date.today() used (acceptable for this use case)

    # Allow certain annotation patterns
    "ANN204",   # Missing return type annotation for __init__ (obvious that it returns None)

    # Ignore rules that conflict with formatter
    "COM812",   # Trailing comma missing (conflicts with formatter)

    # Temporarily ignore line length and some code quality issues until CI is working
    "E501",     # Line too long (will address after CI is working)
    "SIM102",   # Nested if statements (acceptable for clarity)
    "BLE001",   # Blind exception handling (sometimes needed for robustness)
    "ERA001",   # Commented code (sometimes useful for context)
    "PERF401",  # List comprehension (sometimes clarity is better than performance)
    "NPY002",   # Legacy numpy random (acceptable for this use case)
    "RUF001",   # Ambiguous characters (mathematical symbols are intentional)

    # Ignore naming and style issues for external API models
    "N815",     # mixedCase variable names (from external APIs)
    "D103",     # Missing docstring in public function (not all need docstrings)
    "D107",     # Missing docstring in __init__ (obvious what they do)
    "SIM105",   # Use contextlib.suppress (try/except is clearer)
    "DTZ007",   # Naive datetime (dates are fine without timezone)
    "RET504",   # Unnecessary assignment (sometimes improves readability)
    "S311",     # Pseudo-random generators (not for cryptographic use)
    "ANN001",   # Missing type annotation for function argument (legacy code)
    "ANN202",   # Missing return type annotation for private function (can be inferred)
    "EM102",    # Exception must not use f-string (sometimes convenient)
    "D105",     # Missing docstring in magic method (obvious what they do)
    "PLC0415",  # Import should be at top-level (sometimes needed to avoid circular imports)
    "TRY003",   # Avoid specifying long messages outside exception class (descriptive messages are good)

    # Allow certain patterns in tests
    "S101",   # Use of assert detected (needed in tests)
    "PLR2004", # Magic value used in comparison (common in tests)

    # Allow certain patterns for data science/ML code
    "PD",     # pandas-vet rules (can be overly restrictive for our use case)

    # Allow certain todo patterns
    "FIX002", # Line contains TODO (we want TODOs)
    "TD002",  # Missing author in TODO
    "TD003",  # Missing issue link in TODO
]

[tool.ruff.lint.per-file-ignores]
# Allow certain patterns in test files
"tests/**/*.py" = [
    "ANN",     # Missing type annotations (not critical for tests)
    "D",       # Missing docstrings (not critical for tests)
    "S",       # Security issues (not critical for tests)
    "SLF001",  # Private member accessed (common in tests)
]

# Allow certain patterns in notebooks
"*.ipynb" = [
    "ALL",     # Skip all checks for notebooks (they're scratch pads)
]

[tool.ruff.lint.pydocstyle]
# Use Google docstring style
convention = "google"

[tool.ruff.lint.isort]
# Configure import sorting
known-first-party = ["apostle_predictor"]
